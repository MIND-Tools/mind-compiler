<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE section [
<!ENTITY % myents SYSTEM "../shared.ent" >
%myents;
]>
<section id="adl" xmlns="http://docbook.org/ns/docbook" version="5.0">
  <title>Architecture Description Language</title>
  <titleabbrev>ADL</titleabbrev>
  <para>The MIND toolset uses an Architecture Description Language (ADL) for capturing the
    architecture of an application. In a nutshell, the ADL language provides first-level constructs
    for defining components in terms of the interfaces they require and provide and to specify their
    implementations either by referencing a set of C-based implementation files or by assembling a
    set of sub-components. </para>

  <para>
    An architecture definition defined in ADL may be under three forms :
    <variablelist>
      <varlistentry>
        <term>Primitive component definition</term>
        <listitem>
          <para>defines a component whose implementation is provided by a set of C-based files.
          </para>          
      </listitem>
      </varlistentry>
      <varlistentry>
        <term>Composite component definition</term>
        <listitem>
          <para>defines a component whose implementation is assembled from a set of sub-components 
            which are bound together.
          </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Component type definition</term>
        <listitem>
          <para>defines a component's abstract architecture in terms of the interfaces it requires and provides.
          The purpose of a component type definition is the specification of abstract architectures that can be
          reused with different concrete implementations. 
          </para>
        </listitem>
      </varlistentry>
    </variablelist>
  </para>


   <example>
     <title>Primitive component definition</title>
     <programlisting linenumbering="numbered" language="adl"> primitive foo.bar.MyPrimitiveComponent {

   provides foo.Itf1 as aProvidedInterface;
   provides foo.Itf2 as anotherProvidedInterface;
   requires foo.bar.Itf3 as aRequiredInterface;
  
   source myImplementation.c;
 }</programlisting>

          <para>
            In the above primitive component definition: 
            <itemizedlist>
              <listitem>
                <para>Line 3 specifies that the component provides an interface whose name is 
                  <varname>aProvidedInterface</varname> and whose signature is <classname>foo.Itf1</classname>. 
                  The signature of an interface refers to an interface definition which is captured in a
                  separate IDL file. For further information about the IDL,
                  see <xref linkend="idl"/>;</para>
              </listitem>
              <listitem>
                <para>Line 4 specifies that the component provides a second interface whose name is 
                  <varname>anotherProvidedInterface</varname> and whose signature is 
                  <classname>foo.Itf2</classname>;</para>
              </listitem>
              <listitem>
                <para>Line 5 specifies that the component requires an interface whose name is 
                  <varname>aRequiredInterface</varname> and whose signature is 
                  <classname>foo.bar.Itf3</classname>;</para>
              </listitem>
              <listitem>
                <para>Finally, line 7 specifies that the implementation of this primitive component is
                  provided in a file called <filename>myImplementation.c</filename>. For further 
                  information about the component implementation in C language, see <xref linkend="c"/>.
                </para>
              </listitem>
            </itemizedlist>
          </para>
        </example>

  <example>
    <title>Composite component definition</title>
    <programlisting linenumbering="numbered" language="adl"> composite foo.bar.MyCompositeComponent {

   provides foo.Itf1 as itf1;
   requires foo.bar.Itf3 as itf2;
  
   contains foo.bar.MyPrimitiveComponent as aSubComponent;
   contains foo.YourComponent as anotherSubComponent;
  
   binds anotherSubComponent.requiredItf1 
      to aSubComponent.anotherProvidedInterface;

   binds this.itf1 to aSubComponent.aProvidedInterface;
 }</programlisting>
    
    <para>
      In the above composite component definition: 
      <itemizedlist>
        <listitem>
          <para>Line 6 specifies that the defined composite component contains a sub-component 
              whose name is <varname>aSubComponent</varname> which is defined in a separate ADL definition
              called <classname>foo.bar.MyPrimitiveComponent</classname>. For further details about 
              sub-component declarations, see 
              <xref linkend="adl-subcomp"/>;</para>
        </listitem>
        <listitem>
          <para>Line 7 specifies that the defined composite component contains a second sub-component 
              called <varname>anotherSubComponent</varname> which is defined in a separate ADL 
              definition called <classname>foo.YourComponent</classname>;</para>
        </listitem>
        <listitem>
          <para>Line 9 and 10 specify that the interface <varname>requiredItf1</varname> of the
            sub-component called <varname>anotherSubComponent</varname> is bound to the interface 
            <varname>anotherProvidedInterface</varname> of the sub-component 
            called <varname>aSubComponent</varname>. For more  information about binding declarations see 
              <xref linkend="adl-bind"/>;</para>
        </listitem>
        <listitem>
          <para>Finally, line 12 specifies that the interface <varname>itf1</varname> of the defined composite 
          component is bound to the interface <varname>aProvidedInterface</varname> of the sub-component
          called <varname>aSubComponent</varname>. In this binding statement,     
          the <code>"this"</code> keyword designates the defined composite component.
          </para>
        </listitem>
      </itemizedlist>
    </para>
  </example>

  <section id="adl-file">
  <title>ADL Files</title>
  <para>
    ADL definitions are written in ADL files. An ADL file contains one and only one
    <emphasis>ADL definition</emphasis>
    with a unique <glossterm linkend="FQN">fully-qualified-name</glossterm>.
    The name of an ADL file must correspond to the simple-name of the definition it contains suffixed by 
    <filename>'.adl'</filename>. The file must be located in a directory that corresponds to the package-name 
    of the definition.
    For example, a definition whose fully-qualified-name is <classname>foo.bar.MyComponent</classname>
    must be located in a file <filename>foo/bar/MyComponent.adl</filename>
  </para>
  </section>



<!--#########################################################################-->
<!-- Interfaces                                                              -->
<!--#########################################################################-->
  
  <section id="adl-itf">
    <title>Interface declarations</title>
    <para>Interfaces are the acces points of a component. Components may have two 
      kinds of interfaces. That is, <emphasis>provided interfaces</emphasis> (a.k.a.
      server interfaces) are implemented by the component whereas 
      <emphasis>required interfaces</emphasis> (a.k.a. client interfaces) may be
      invoked by the component. An interface has a <emphasis>signature</emphasis> that is defined in 
      the IDL language (see <xref linkend="idl"/>) and a <emphasis>name</emphasis> that must be unique
      among all the interfaces of the definition (either provided or required).</para>

    <para><emphasis>Provided</emphasis> interfaces are declared with the <code>"provides"</code> keyword 
      followed by its signature and its name separated by the <code>"as"</code>
      keyword. Similarly, <emphasis>required</emphasis> interfaces are declared with the <code>"requires"</code> keyword 
      followed by its signature and its name separated by the <code>"as"</code>
      keyword.</para>
      
    <example>
      <title>Simple Interface declaration</title>
      <programlisting linenumbering="numbered" language="adl"> provides foo.Itf1 as aProvidedInterface;
 provides foo.Itf1 as anotherProvidedInterface;
 requires foo.bar.Itf3 as aRequiredInterface;</programlisting>
 
      <para>
        In the above code excerpt: 
        <itemizedlist>
          <listitem>
            <para>Line 1 declares a provided interface whose name is 
              <varname>aProvidedInterface</varname> and whose signature is defined
              in the IDL definition called <classname>foo.Itf1</classname>.</para>
          </listitem>
          <listitem>
            <para>Line 2 declares a second provided interface interface whose name 
              is <varname>anotherProvidedInterface</varname> and whose signature is 
              <classname>foo.Itf1</classname>. Note that a given component may provide
              and/or require multiple interfaces with the same signature with 
              different names.</para>
          </listitem>
          <listitem>
            <para>Line 3 declares that the component requires an interface whose name is 
              <varname>aRequiredInterface</varname> and whose signature is 
              <classname>foo.bar.Itf3</classname>.</para>
          </listitem>
        </itemizedlist>
      </para>
    </example>
      
    <para>An interface may be tagged as <emphasis>optional</emphasis>. 
      If a required interface is tagged as optional, the component requiring this interface
      is expected to be functional even if this interface is not bound. On the other hand, 
      if a provided interface is tagged as optional, the component may not actually 
      provide the implemenation of this interface. Therefore, only optional
      required interfaces can be bound to optional provided interfaces. This constaint is
      discussed more in details in  
      <xref linkend="adl-bind"/>. To specify that an interface
      is optional, the <code>"optional"</code>
      keyword must be added after the <code>"provides"</code> or <code>"requires"</code>
      keywords in the interface declaration.
      
      <note>
        <para>Optional provided interfaces are not fully supported in the current
          &productName; toolchain.</para>
      </note>
    </para>
    
    <example>
      <title>Optional interface declaration</title>
      <programlisting linenumbering="numbered" language="adl"> provides optional foo.Itf1 as aProvidedInterface;
 requires optional foo.bar.Itf3 as aRequiredInterface;</programlisting>
    </example>
    
    <para>An interface may also be a <emphasis>collection</emphasis> interface.
      A collection interface may be considered as an array of interfaces of the same type,
      which can be accessed using an index operator. A required collection interface can be
      bound to several provided interfaces (i.e. each element in the array may be 
      connected to a different provided interface). 
      A provided collection interface allows supporting distinct implementations of the same interface type within the
      same component. To specify that an interface is actually a collection interface,  
      the number of interfaces that are collected together must be defined between square
      brackets (i.e. <code>"["</code> SIZE <code>"]"</code>) right after the name
      of the interface, similarly to array variable definitions in C.

      <note>
        <para>The current &productName; toolchain does not support the collection interfaces where the
          size is not statically specified in the ADL definition.</para>
      </note>
    </para>
    
    <example>
      <title>Collection interface declaration</title>
      <programlisting linenumbering="numbered" language="adl"> provides foo.Itf1 as aProvidedInterface[4];
 requires foo.bar.Itf3 as aRequiredInterface[10];</programlisting>
    </example>
    
    <para>An interface can be both optional and collection. In the case of a provided interface,
      being both collection and optional means the component may not provide some (or any) implementations
      of the interface. On the other hand, in the case of a required interface, being both
      collection and optional means that some (or all) of the interfaces may not be bound whereas the 
      component is still suppsed to be functional.</para>
  </section>

<!--#########################################################################-->
<!-- Implementation                                                          -->
<!--#########################################################################-->
  
  <section id="adl-impl">
    <title>Implementation declarations</title>
    <para>Primitive components are implemented in C language using some macros 
      The ADL definition of primitive components must specify the location of the
      source files providing the implementation of the component.
    </para>
    
    <para> There are two constructs in the ADL for specifying the 
      implementation of a primitive component. The first one is used for specifying the 
      declaratrion of the <emphasis>private-data</emphasis> of the component. The 
      second one is used for specifying the set of <emphasis>implementation files</emphasis> of the component. 
      Further information about the syntactic extensions to the C language that need to 
      be respected in those C implementation files are discussed in detail in <xref linkend="c"/>. 
      The rest of this section focuses only on ADL related aspects.
    </para>
    
    <section id="adl-impl-data">
      <title>Private data definition</title>

      <para>The specification of component's private-data may be done under two
        different forms using the ADL:</para>
      <orderedlist>
        <listitem>
          <para>The private-data structure definition can be put in a separate header file,
            that is referenced in the ADL definition using the <code>"data"</code> keyword 
            followed by the path to this header file;</para>
        </listitem>
        <listitem>
          <para>Or, the private-data structure definition can be inlined directly in the 
            ADL definition in between double curly braces (<code>"{{"</code> 
            and <code>"}}"</code>) following the <code>"data"</code> keyword;</para>
            
          <warning><para>Source-code inlined in the ADL file is not parsed by the 
            &productName; toolchain. It is escaped by the double curly brace (<code>"{{"</code> 
            and <code>"}}"</code>). Please make sure that consecutive curly 
            braces in the inline source-code are separated by at least one 
            whitespace character.</para></warning>
        </listitem>
      </orderedlist>
      
      <para>A primitive component definition may have a maximum of one private-data definition.
        On the other hand, composite and type definitions cannot specify private-data.</para>
      
      <para>When the private-data structure is defined in a separate header file, 
        the latter should contains only the definition of the private-data structure. It is
        not necessary to include it in the implememtation files (this is done automatically 
        by the generated code). Moreorver it must not be included by implementations of 
        other components.</para>
      
      <para>See <xref linkend="c-prvdecl"/> for details on the syntax to be 
        used to define component's private data.</para>

      <example>
        <title>Private data definition in a separate header file</title>
        <programlisting linenumbering="numbered" language="adl"> data myComponentData.h;</programlisting>
        
        <para>The above code excerpt specifies that the component's private-data 
          are defined in the file called <filename>myComponentData.h</filename>. 
          The latter file should look-like :</para>
          
        <programlisting language="cpl" linenumbering="numbered"> #ifndef MY_COMPONENT_DATA_H
 #define MY_COMPONENT_DATA_H

 struct {
   int a, b;
   char c[10];
 } PRIVATE;
 
 #endif</programlisting>
        
      </example>
      
      <example>
        <title>Private data definition inlined in the ADL</title>

        <programlisting linenumbering="numbered" language="adl"> data {{
   struct {
     int a, b;
     char c[10];
   } PRIVATE;
 }};</programlisting>

        <para>The above code excerpt makes an inlined definition of private-data structure
          directly in the ADL file.</para>
      </example>
    </section>
    
    <section id="adl-impl-source">
      <title>Component implementation declaration</title>
      
      <para>The implementation of a primitive component (i.e. the implementation
        of its provided interfaces) is done using the C language. For convenience reasons, 
        the implementation of a primitive component may be split into multiple source files.
        Implementation files must be referenced in the ADL definition of primitive components
        to make sure the MIND toolset integrates those files with the generated glue code.
        The declaration of implementation files is done using the <code>"source"</code> 
        keyword followed by the path of the source file.</para>
      
      <para>Similarly to private data structure definition, the implementation code 
        may also be inlined in the ADL using double curly braces(<code>"{{"</code>
        and <code>"}}"</code>) following the <code>"source"</code> keyword.</para>
        
      <example>
        <title>Component implementation in a separate C file</title>
        <programlisting linenumbering="numbered" language="adl"> source myComponentImpl.c;</programlisting>

        <para>In the above code excerpt, specifies that implementation of the 
          component is located in the <filename>myComponentImpl.c</filename> file. 
          The latter file should look-like :</para>
        
        <programlisting language="cpl" linenumbering="numbered"> #include &lt;stdio.h&gt;

 int METH(adderItf, add) (int a, int b) {
   printf("in adderItf.add\n");
   return a + b;
 }</programlisting>
        
      </example>
      
      <example>
        <title>Component implementation inlined in the ADL</title>
        <programlisting linenumbering="numbered" language="adl"> source {{
   #include &lt;stdio.h&gt;

   int METH(adderItf, add) (int a, int b) {
     printf("in adderItf.add\n");
     return a + b;
   }
 }};</programlisting>
 
        <para>In the above code excerpt, the implementation of the primitive 
          component is inlined in the ADL file.</para>
      </example>
      
      <para>Moreover, the <code>"source"</code> keyword may be followed by a path 
        to a pre-compiled file (<code>".o"</code>, <code>".a"</code>, <code>".so"</code>,
        or <code>.dll</code> file). In that case, the source file will only be added on
        the linker command. This is particularly usefull to define a component that wraps a
        pre-compiled C library.</para>
    </section>
  </section>
  
<!--#########################################################################-->
<!-- Attribute                                                               -->
<!--#########################################################################-->
  
  <section id="adl-attr">
    <title>Attribute declarations</title>
    
    <para>Attributes are component's data that are declared and initialized in 
      the ADL. This is very useful feature to set some initial parameters for a component 
      (e.g. size of a buffer component). Moreover, if the component implements the 
      <emphasis>attribute-controller</emphasis> interface (see <xref linkend="adv-ctrl-ac"/> for more detail),
      the attributes may also be read and modified at runtime by other components.</para>
    
    <para>Attribute declarations are done using the <code>"attribute"</code> keyword followed 
      by a type, a name and optionnaly an initial value.</para>
    <note><para>Currently only type <code>"int"</code> is supported in the &productName; 
      toolchain.</para></note>
    <para>The initial value of an attribute can be a literal integer (which may optionally be 
      signed with <code>"+"</code> or <code>"-"</code>) written in decimal, 
      hexadecimal or octal base. The initial value of an attribute can also be a 
      reference to a <emphasis>definition parameter</emphasis> as described in <xref linkend="adl-para"/>.</para>
    
    <example>
      <title>Attribute declarations</title>
      <programlisting linenumbering="numbered" language="adl"> attribute int attr1 = -2;
 attribute int attr2 = 0xff43dc5;
 attribute int attr3 = myDefinitionParam;</programlisting>
      
      <para>
        In the above code excerpt: 
        <itemizedlist>
          <listitem>
            <para>Line 1 declares an attribute called <varname>attr1</varname> that 
              is initialized to <code>-2</code>; </para>
          </listitem>
          <listitem>
            <para>Line 2 declares another attribute called <varname>attr2</varname> that 
              is initialized to an hexadecimal value;</para>
          </listitem>
          <listitem>
            <para>Line 3 declares an attribute called <varname>attr3</varname> that 
              is initialized using the definition parameter called
              <varname>myDefinitionParam</varname>.</para>
          </listitem>
        </itemizedlist>
      </para>
    </example>
  </section>
  
<!--#########################################################################-->
<!-- Sub-Component                                                           -->
<!--#########################################################################-->
  
  <section id="adl-subcomp">
    <title>Sub-component declarations</title>
    <para>The implementation of a composite component, i.e. the implementation
      of its provided interfaces, is done by composing a set of sub-components
      which are bound together in a consistent way. For that purpose, the ADL
      definition of a composite component may declare a list of sub-components
      which make part of its implementation.</para>
    <para>A sub component is declared using the <code>"contains"</code> keyword 
      followed by a reference to an ADL definition and its local name separated
      by the <code>"as"</code> keyword. The local name associated to a sub-component
      must be unique within the encapsulating composite definition.
    </para>
    
    <example>
      <title>Sub-component declaration</title>
      <programlisting linenumbering="numbered" language="adl"> contains foo.bar.MyPrimitiveComponent as aSubComponent;
 contains foo.YourComponent as anotherSubComponent;</programlisting>
      <para>
        <note>
          <para>Line 1 declares a sub-component called <varname>aSubComponent</varname> that 
            is an instance of the definition <classname>foo.bar.MyPrimitiveComponent</classname></para>
        </note>
      </para>
    </example>
  </section>
  
<!--#########################################################################-->
<!-- Binding                                                                 -->
<!--#########################################################################-->
  
  <section id="adl-bind">
    <title>Binding declarations</title>
    <para>Components' interfaces must be bound together in order to establish a communication
      between them. A binding (in its simplest form) is a point-to-point connection
      that links a required interface (the <emphasis>client side</emphasis> of the binding) to a
      provided interface (the <emphasis>server side</emphasis> of the binding).
      Composite component definitions declare a list of bindings to 
      assemble its sub-components together in a consistent way.</para>
    
    <para>A binding is specified using the <code>"binds"</code> keyword followed 
      by the specification of the client side and the server-side which are spearated by the
      <code>"to"</code> keyword. Both client and server sides of a binding are specified with
      the local-name of the sub-component and the name of the interface
      of this sub-component separated by a dot (<code>"."</code>).
      The special <code>"this"</code> 
      keyword can be used to refer to the encapsulating composite component definition.
      In the case of collection interfaces, the binding declaration may also specify
      the indexes of the interfaces to be bound. In this case, the index is specified in 
      between square brackets following the interface name. </para>
      
    <example>
      <title>Binding declarations</title>
      <programlisting linenumbering="numbered" language="adl"> binds subComp1.itf1 to subComp2.itf4;
 binds subComp1.itf2[3] to subComp2.itf2;
 binds this.itf1 to subComp1.itf3;
 binds subComp2.itf1 to this.itf2;</programlisting>
      
      <para>
        In the above code excerpt: 
        <itemizedlist>
          <listitem>
            <para>Line 1 declares a binding from the interface <varname>itf1</varname>
              of the sub-component <varname>subComp1</varname> to the interface 
              <varname>itf4</varname> of the sub-component <varname>subComp2</varname>;</para>
          </listitem>
          <listitem>
            <para>Line 2 declares a binding from the forth interface of the 
              <varname>itf2</varname> collection interface of the <varname>subComp1</varname> 
              sub-component. Note that the collection interfaces indexes start at zero;</para>
          </listitem>
          <listitem>
            <para>Line 3 and 4 declare two bindings designating
              respectively a required and a provided interface of the encapsulating 
              composite component.</para>
          </listitem>
        </itemizedlist>
      </para>
    </example>
    
    <para>TODO detail rules of valid bindings
      <itemizedlist>
        <listitem><para>Multiple client interfaces can be connected to a single server interface, whereas 
          a single client interface cannot be connected to multiple server interfaces. A collection client 
          interface is needed for that purpose.</para></listitem>
      </itemizedlist>
    </para>
  </section>
  
<!--#########################################################################-->
<!-- Import                                                                  -->
<!--#########################################################################-->
  
  <section id="adl-import">
    <title>Import statements</title>
    <para>Import statements allow shortening the references to other ADL or IDL 
      definitions using their simple-names 
      rather than their <glossterm linkend="FQN">fully-qualified-name</glossterm>. 
      This feature is directly inspired from the Java programming language.</para>

    <para>Import statements must be placed at the very begining of ADL files, preceeding any 
      <code>"primitive"</code>, <code>"composite"</code> or <code>"type"</code>
      keywords. An import statement is composed of the <code>"import"</code> keyword followed by a 
      fully-qualified-name or a package-name itself followed by <code>".*"</code>.</para>

    <para>The first form (i.e. fully-qualified-name) allows to reference the specified 
      ADL or IDL definition using its simple name.</para>
    <para>The second form (i.e. package-name followed by <code>".*"</code>) allows to
      reference any ADL or IDL definition belonging to specified package using their simple names.</para>
    
    <para>ADL or IDL definitions beloning to the same package as the current definition are 
      implicitly imported and can be referenced with there simple-name</para>

    <example>
      <title>Import statements</title>
      <para>The following example can be refactored to use import</para>
      <programlisting linenumbering="numbered" language="adl"> composite foo.bar.MyCompositeComponent {

   provides foo.Itf1 as itf1;
   requires foo.bar.Itf3 as itf2;
  
   contains foo.bar.MyPrimitiveComponent as aSubComponent;
   contains foo.YourComponent as anotherSubComponent;
  
   ...
 }</programlisting>
      <para>Which gives : </para>
      <programlisting linenumbering="numbered" language="adl"> import foo.bar.Itf3;
 import foo.*;
 
 composite foo.bar.MyCompositeComponent {

   provides Itf1 as itf1;
   requires Itf3 as itf2;
  
   contains MyPrimitiveComponent as aSubComponent;
   contains YourComponent as anotherSubComponent;
  
   ...
 }</programlisting>
    
      <para>
        In the above code excerpt: 
        <itemizedlist>
          <listitem>
            <para>Line 1 imports the IDL definition called <classname>foo.bar.Itf3</classname> 
              which allows to shorten the declaration of the <varname>itf2</varname>
              interface at line 7 using the simple name (i.e. <code>Itf3</code>)
              rather than its fully qualified name (i.e. <code>foo.bar.Itf3</code>).</para>
          </listitem>
          <listitem>
            <para>Line 2 imports the whole package called <classname>foo</classname>. 
              This allows to shorten the references at line 6 and 10.</para>
          </listitem>
          <listitem>
            <para>At line 9, the ADL definition called <classname>foo.bar.MyPrimitiveComponent</classname>
              can be referenced by using its simple name since it is in the same
              package as the encapsulating (current) definition (<classname>foo.bar.MyCompositeComponent</classname>).</para>
          </listitem>
          <listitem>
            <para>The import statement at line 1 may be considered as useless since it imports 
              an IDL definition which is already in the same package as the current definition. Nevertheless,  
              such an import statement may be usefull in some cases to explicitly import an ADL or IDL definition
              in order to avoid name preemption that may occur. For instance, if another IDL
              whose simple name is <classname>Itf3</classname> is defined in the
              <classname>foo</classname> package, then the import statement at 
              line 2 would import the latter and therefore <classname>Itf3</classname>
              would be resolved in <classname>foo.Itf3</classname> rather than in
              <classname>foo.bar.Itf3</classname>. 
              For more information about the simple-name resolution rules, please refer to <xref linkend="adl-import-order"/>.</para>
          </listitem>
        </itemizedlist>
      </para>
    </example>

    <section id="adl-import-order">
      <title>Resolution of simple names</title>
      <para>Names used in ADL definitions for the declaration of sub-components 
        and/or the spoecification of interface signatures have  
        to be resolved into fully-qualified-names. The way &productName; toolchain
        proceed to this name resolution is as follow :</para>
      <procedure>
        <step>
          <para>If the name contains at least one dot (<code>"."</code>), then it is a 
            fully-qualified-name. Therefore, there is nothing to do.</para>
        </step>
        <step>
          <para>Otherwise, the name is a simple-name. In this case, 
            for each import statement found in the ADL file (respecting the order
            of declaration):</para>
          <substeps>
            <step>
              <para>If the import statement contains a fully-qualified-name
                whose simple-name matches the name to be resolved, then the resolved
                fully-qualified-name is the one imported by this statement.</para>
            </step>
            <step>
              <para>If the import statement contains a package import (a 
                package-name followed by <code>".*"</code>) and there exist an ADL
                or IDL definition whose fully-qualified-name is made of the imported
                package-name and the referenced simple-name, then the resolved 
                fully-qualified-name is this one.</para>
            </step>
            <step><para>Otherwise, try the next import.</para></step>
          </substeps>
        </step>
        <step>
          <para>If the simple name has not been resolved by the import statements, 
            try to find an ADL or an IDL in the same package as the current definition.</para>
        </step>
        <step>
          <para>Finally, try to find an ADL or IDL in the default package (the 
            package with an empty name)</para>
        </step>
      </procedure>
    </section>
  </section>
  
<!--#########################################################################-->
<!-- Extends                                                                 -->
<!--#########################################################################-->
  
  <section id="adl-extend">
    <title>Definition inheritance</title>
    <para>The ADL has a definiton inheritence feature in order to support the design
    of reusable ADL definitions. That is, an ADL definiton can
    extend one or more definitions so that it inherits from the architectural elements
    defined by the latters. In some cases, the inherited elements may also be overriden 
    in the inheriting definition. </para>

    <para>The extended definitions are specified after the name of the definition using the 
      <code>"extends"</code> keyword followed by a comma-separated list of ADL name.</para>
    
    <para>The following rules apply to type, primitive and composite definitions:
    	<itemizedlist>
    	  <listitem><para>A type definition can only extend other type definitions.</para></listitem>
    	  <listitem><para>A primitive definition can only extend type and primitive definitions.</para></listitem>
    	  <listitem><para>A composite definition can only extend type and composite definitions.</para></listitem>
        </itemizedlist>
    </para>
    
    <para>When an ADL definitions extends another one, the interface,
      implementation, attribute, sub-component and binding declarations are all
      inherited. On the other hand, import statements as well as definition parameters and  
      template variables are not inherited.</para>
    
    <para>Inherited interface, sub-component and attribute declarations can be
      overridden by declaring new architectural element of the same kind and with 
      the same name.</para>
    
    <para>Inherrited bindings can be overridden by declaring a new 
      binding with the same client-side.</para>
    
    <para>Private-data declaration can be overridden simply by specifying a new
      private-data declaration.</para>
    
    <para>Finnaly, source declarations are simply inherited and cannot be overridden.
      Nevertheless, a definition that inherits source declaration can specify additional
      implementation files.</para>

    <warning>
      <para>When a definition overrides the private-data definition and inherits
        the sources of the definition it extends,
        it is the responsability of the developper to make sure that the new component's
        private-data structure is compatible with the inherited sources.</para>
    </warning>
    
    <example>
      <title>Definition extension</title>
      <para>Given the following definitions :</para>
      <programlisting linenumbering="numbered" language="adl"> type foo.bar.MyType {
   provides Itf1 as itf1;
   requires Itf2 as itf2;
 }</programlisting>
      <programlisting linenumbering="numbered" language="adl" startinglinenumber="20"> primitive foo.bar.APrimitive {
   provides Itf3 as itf3;
   
   source aPrimitiveImpl.c;
   
   attribute int attr1 = 2; 
 }</programlisting>
      <programlisting linenumbering="numbered" language="adl" startinglinenumber="40"> primitive foo.bar.AnotherPrimitive 
     extends MyType, APrimitive {
   
   source anotherPrimitiveImpl.c;
   
   @Override
   attribute int attr1 = 4;
 }</programlisting>
      <para>The previous definition is equivalent to : </para>
      <programlisting linenumbering="numbered" language="adl" startinglinenumber="60"> primitive foo.bar.AnotherPrimitive {
   provides Itf1 as itf1;
   requires Itf2 as itf2;
   provides Itf3 as itf3;
   
   source aPrimitiveImpl.c;
   source anotherPrimitiveImpl.c;
   
   attribute int attr1 = 4;
 }</programlisting>

      <para>
        In the above excerpt of code:
        <itemizedlist>
          <listitem>
            <para>Line 41 specifies that the <classname>foo.bar.AnotherPrimitive</classname> 
              extends the type definition <classname>foo.bar.MyType</classname>
              and the primitive definition <classname>foo.bar.APrimitive</classname>.</para>
          </listitem>
          <listitem>
            <para>At line 46, the declaration of the attribute <varname>attr1</varname>
              overrides the declaration of the attribute with the same name at line 25. 
              The <code>@Override</code> annotation at line 45 specifies that the 
              declaration of the attribute is expected to override the inherited
              attribute (see <xref linkend="adl-annot-override"/> for more details.).</para>
          </listitem>
        </itemizedlist>
      </para>
    </example>
  </section>

<!--#########################################################################-->
<!-- Parameter                                                               -->
<!--#########################################################################-->
  
  <section id="adl-para">
    <title>Definition parameters</title>
    <para>The ADL supports definition parameters to allow component attributes to be 
      assigned in a parameterized way. This feature improves the reusability of 
      architecture descriptions. </para>
    <para>The definition parameters are specified in a comma separated list
      between parenthesis right after the name of the definition 
      (and before the <code>"extends"</code> keyword if any).</para>
    <para>When a parameterized definition is referenced in another ADL definition, either for the 
      declaration of a sub-component, or for an inheritence specification, the value 
      of these parameters must be specified. The value specification must be done
      as a comma-separated list in between paranthesis either respecting 
      the order of declaration of parameters, or in a
      <code><replaceable>name</replaceable>=<replaceable>value</replaceable></code> 
      fashion.</para>
      
    <para>Types of parameters are inferred from the type of the attribute 
      they assign. A given parameter can be used several times to initialize multiple
      attributes if these attributes have the same type.</para>
    
    <example>
      <title>Definition parameters</title>
      
      <programlisting linenumbering="numbered" language="adl"> primitive foo.bar.APrimitive(a, b) {
   ...
   attribute int attr1 = a;
   attribute int attr2 = b;
 }</programlisting>
      <programlisting linenumbering="numbered" language="adl" startinglinenumber="10"> primitive foo.bar.AnotherPrimitive(c) extends APrimitive(c, c) {
   ...
 }</programlisting>
      <programlisting linenumbering="numbered" language="adl" startinglinenumber="20"> composite foo.bar.AComposite(d) {
   ...
   contains APrimitive(a=d, b=10) as subComp1;
   contains AnotherPrimitive(20) as subComp2;
   ...
 }</programlisting>
      <para>
        In the above excerpt of code:
        <itemizedlist>
          <listitem>
            <para>Line 1 specifies that definition <classname>foo.bar.APrimitive</classname>
              has two parameters called <varname>a</varname> and <varname>b</varname>.
              These parameters are used to initialize attributes <varname>attr1</varname>
              and <varname>attr2</varname>, respectively;</para>
          </listitem>
          <listitem>
            <para>At line 10, the definition <classname>foo.bar.AnotherPrimitive</classname>
              have one parameter called <varname>c</varname>. This definition 
              extends the <classname>foo.bar.APrimitive</classname> and pass the 
              <varname>c</varname> parameter as value of both <varname>a</varname>
              and <varname>b</varname> parameters;</para>
          </listitem>
          <listitem>
            <para>At line 22, parameter values are given in a <code><replaceable>name</replaceable>=<replaceable>value</replaceable></code> 
              fashion. The sub-component <varname>subComp1</varname> is
              an instance of the <classname>foo.bar.APrimitive</classname> definition
              where the value of its <varname>attr1</varname> attribute is given
              by the <varname>d</varname> parameter of the composite component definition
              and the value of its <varname>attr2</varname> attribute is <code>10</code>;</para>
          </listitem>
          <listitem>
            <para>At line 23, the sub-component <varname>subComp2</varname> is
              an instance of the <classname>foo.bar.AnotherPrimitive</classname>
              definition. Values of both <varname>attr1</varname> and 
              <varname>attr2</varname> of this component are <code>20</code>.</para>
          </listitem>
        </itemizedlist>
      </para>
    </example>
  </section>

<!--#########################################################################-->
<!-- Template                                                                -->
<!--#########################################################################-->
  
  <section id="adl-tmpl">
    <title>Generic definitions</title>
    <para>
      Generic definitions is another feature of the ADL for improving 
      the reusability of composite component definitions. Using generic definitions,
      programmers may define abstract composite components where only the type of some 
      sub-components is known rather than there concrete implementations. Such generic
      component definitions cannot be instantiable directly. But, they can be reused 
      in other definitions where the concrete implementations of these sub-components are specified. 
      For instance, a generic definition 
      may be used for describing a system architecture which contains a memory allocator
      component without specifying the concrete implementation details of the latter component.
      This generic definition can be extended later on, in another definition where 
      a platform specific memory component is specified in order to map the defined system architecture
      on a given HW platform.</para>

    <para>To turn a composite component definition into a generic definition,
      a list of <emphasis>template variables</emphasis> should be defined
      between inferior and superior symbols (<code>"&lt;"</code>, <code>"&gt;"</code>)
      right after the name of the component and before 
      the <code>"extends"</code> keyword or the definition parameters, if any.
      Each template variable must specify the type definition which it <emphasis>conforms</emphasis> to.
    </para>
    
    <example>
      <title>Template variable declaration</title>
       <programlisting linenumbering="numbered" language="adl"> composite foo.bar.AComposite
     &lt;T conformsto Type1, U conformsto Type2&gt; {
   ...
 }</programlisting>
 
      <para>
        <note>
          <para>Line 2 declares two template variables called <varname>T</varname>
            and <varname>U</varname> that conforms to the type definitions
            <classname>Type1</classname> and <classname>Type2</classname> 
            respectively.</para>
        </note>
      </para>
    </example>
    
    <para>Template variables can be used to specify the definition of a sub-component.
      Doing so, only the interfaces of the sub-cmponent are specifyed by the type
      which the template variable conforms to. The concrete definition of the sub-component
      will be given by the value that is assigned to the template variable 
      when the generic definition is referenced.</para>

    <para>When referencing a generic definitions, values of its template variables 
     are specified between inferior and superior symbols (<code>"&lt;"</code>, <code>"&gt;"</code>)
     in a comma separated list either respecting the order of declaration of template 
     variables, or in a <code><replaceable>name</replaceable>=<replaceable>value</replaceable></code> 
     fashion.</para>

    <para>Values given to template variables must be a reference to a concrete 
      ADL definition (or a reference to another template variable) that <emphasis>conforms to</emphasis>
      the type of the template variable. This means that the definition must 
      have the same provided and required interfaces (same name, same signature and same size for collection interfaces);
      it may have additional provided interfaces; it may also have additional 
      required interfaces but these latters must be optional. Note that it is 
      neither necessary or sufficient that a definition extends (directly or 
      transitively) the type to conform to it.</para>
    
    <example>
      <title>Generic composite component definition</title>
      <programlisting linenumbering="numbered" language="adl"> type foo.bar.MyType {
   provides Itf1 as itf1;
   requires Itf2 as itf2;
 }</programlisting>
      <programlisting linenumbering="numbered" language="adl" startinglinenumber="10"> composite foo.bar.AComposite&lt;T conformsto MyType&gt;  {
   provides Itf1 as itf1;
   
   contains T as subComp1;
   contains AnotherPrimitive as subComp2;
   
   binds this.itf1 to subComp1.itf1;
   binds subComp1.itf2 to subComp2.itf;
 }</programlisting>
      <programlisting linenumbering="numbered" language="adl" startinglinenumber="20"> primitive foo.bar.APrimitive 
     extends MyType {
   source aPrimitiveImpl.c;
 }</programlisting>
      <programlisting linenumbering="numbered" language="adl" startinglinenumber="30"> composite foo.bar.AnotherComposite {
   ...
   contains AComposite&lt;APrimitive&gt; as aSubComp;
   ...
 }</programlisting>

      <para>
        <note>
          <para>In the above excerpt of code:</para>
          <itemizedlist>
            <listitem>
              <para>At line 10, the <classname>foo.bar.AComposite</classname> is a 
                generic definition with one template variable called <varname>T</varname>
                that conforms to the type <classname>foo.bar.MyType</classname>;</para>
            </listitem>
            <listitem>
              <para>At line 13, the sub-component <varname>subComp1</varname> is an 
                instance of the type variable <varname>T</varname>;</para>
            </listitem>
            <listitem>
              <para>At lines 16 and 17, bindings from or to the <varname>subComp1</varname>
                sub-component are checked with the interfaces defines in the 
                <classname>foo.bar.MyType</classname> type definition.
                <varname>subComp1</varname> has a provided interface called 
                <varname>itf1</varname> (this interface is defined at line 2).
                Therefore, the binding declared at line 16 is correct. 
                Similarly, <varname>subComp1</varname> has a required interface
                called <varname>itf2</varname> (defined at line 3) so binding at line 17 is correct.
                Finally, the <varname>subComp1</varname> doesn't have any other mandatory required
                interfaces, so there is no missing binding in this composite component definition.</para>
            </listitem>
            <listitem>
              <para>At line 32, the sub-component <varname>aSubComp</varname> is an
                 instance of the <classname>foo.bar.AComposite</classname> generic 
                 definition where the template parameter <varname>T</varname> takes 
                 <classname>foo.bar.APrimitive</classname> as value. This definition
                 is valid since it conforms to the type definition <classname>foo.bar.MyType</classname>. 
                 Indeed it has the same provided and required interfaces and do not have 
                 additional mandatory required interface.</para>
               <para>Therefore, the sub-component <varname>aSubComp</varname> is a composite 
                 component that contains a <varname>subComp1</varname> sub-component
                 that is an instance of the <classname>foo.bar.APrimitive</classname>
                 definition.</para>
            </listitem>
          </itemizedlist>
        </note>
      </para>
    </example>
    
    <para>The <emphasis>conformsto</emphasis> relationship is indeed quite restrictive. 
      The goal of those restrictions is to ensure that whatever the value of a template variable is, the bindings defined
      in the generic definition are still valid (i.e. binding ends actually exist, and 
      no binding is missing for a mandatory required interface).</para>
    
    <para>Under some circumstances, it may be usefull to extend a generic definition 
      and change the type of one of its template variables. This can be done 
      using a <code>"?"</code> as a value of a template variable. When doing so,
      the definition must ensure that each occurence of the template variable is
      correctly overridden.</para>
      
    <example>
      <title>Extension of generic definitions</title>
      
      <para>This example reuses the definitions presented in the previous example.</para>
      
      <programlisting linenumbering="numbered" language="adl"> type foo.bar.MySecondType 
     extends MyType{
   requires Itf3 as itf3;
 }</programlisting>
      
      <programlisting linenumbering="numbered" language="adl" startinglinenumber="10"> composite foo.bar.YetAnotherComposite&lt;U conformsto MySecondType&gt;
     extends AComposite&lt;?&gt; {

   @Override
   contains U as subComp1;
   ...

   binds subComp1.itf3 to ...;
 }</programlisting>

    <para>
      <note>
        <para>In the above excerpt of code:</para>
        <itemizedlist>
          <listitem>
            <para>At line 10, the <classname>foo.bar.YetAnotherComposite</classname> generic definition
              has one template variable called <varname>U</varname> that conforms
              to the type <classname>foo.bar.MySecondType</classname>;</para>
          </listitem>
          <listitem>
            <para>At line 11, the definition extends the <classname>foo.bar.AComposite</classname> generic definition
              and assignes <code>?</code> as value of the <varname>T</varname> template 
              variable. This means that this template variable doesn't take a concrete
              value, so that each occurrence of this template variable must be overridden
              in the <classname>foo.bar.YetAnotherComposite</classname> definition;</para>
          </listitem>
          <listitem>
            <para>At line 14, the inherited specification of <varname>subComp1</varname>
              sub-component is overridden so that it becomes an instance of the <varname>U</varname>
              template variable.</para>
          </listitem>
          <listitem>
            <para>At line 17, the <varname>itf3</varname> required interface of <varname>subComp1</varname> is
              bound. The bindings of interfaces <varname>itf1</varname> 
              and <varname>itf2</varname> are inherited from <classname>foo.bar.AComposite</classname>.</para>
          </listitem>
        </itemizedlist>
        <para>In this example, the <classname>foo.bar.YetAnotherComposite</classname> generic definition
          cannot extend <code>AComposite&lt;U&gt;</code> since <classname>foo.bar.MySecondType</classname>
          (the type of <varname>U</varname>) doesn't conform to <classname>foo.bar.MyType</classname> 
          (the type of the template parameter of <classname>AComposite</classname>) because it has 
          an additional mandatory required interface.</para>
      </note>
    </para>
    </example>
  </section>
  
<!--#########################################################################-->
<!-- Anonymous                                                               -->
<!--#########################################################################-->
  
  <section id="adl-anonym">
    <title>Anonymous definitions</title>

    <para>As presented in previous sections of this document, each ADL 
      definition has a name and must be placed in a separate file respecting 
      a convention related to its name. This allows the &productName; toolchain
      to find the ADL file of a component using its definition name. However, 
      inlining the definition of a component in where an instance is defined, rather than
      writing it in a separate file may be handy in some circumstances. For that prupose, 
      the ADL supports <emphasis>anonymous definitions</emphasis>, which is a 
      feature inspired from the Java language. This feature is particularly useful for 
      defining an extension specific to a sub-components instance. It may also be useful 
      for defining simple components which have only one instance
      in the application architecture.
    </para>

    <para>An anonymous definition can only be used for defining sub-components.
      In order to specify an anonymous definition
      for a sub-component declaration, the local-name must be
      followed by the specification of the definition nature (i.e either <code>"primitive"</code> 
      or <code>"composite"</code>), itself followed by the content of the anonymous definition between curly 
      braces (<code>"{"</code> and <code>"}"</code>).</para>

    <example>
      <title>Anonymous definition</title>
      
      <programlisting linenumbering="numbered" language="adl"> composite foo.bar.AComposite { 
   ...
   contains as subComp1 
     primitive {
       provides Itf1 as itf1;
       requires Itf2 as itf2;
 
       source myImplementation.c;
     }
   ...
 }</programlisting>
    
      <para>
        <note>
          <para>The architecture of sub-component <varname>subComp1</varname> is defined 
            in an anonymous definition inlined in the surrounding definition. This annonymous
            definition describes a primitive component that specifies 2 interfaces
            and an implementation source file.</para>
        </note>
      </para>
    </example>
    
    <para>An anonymous definition can extends one other definition (multiple inheritence is not 
      supported for anonymous definition). This is done by specifying the extended definition between
      the <code>"contains"</code> and the <code>"as"</code> keywords.</para>
      
      
    <example>
      <title>Anonymous definition that extends another definition</title>
      
      <programlisting linenumbering="numbered" language="adl"> composite foo.bar.AComposite { 
   ...
   contains MyType as subComp1 
     primitive {
       source myImplementation.c;
     }
   ...
 }</programlisting>
    </example>
    
    <para>Anonymous definitions can make use of the surronding definition's parameters and template 
      variables.</para>
      
    <example>
      <title>Anonymous definition using definition parameters</title>
      
      <programlisting linenumbering="numbered" language="adl"> composite foo.bar.AComposite(a) { 
   ...
   contains primitive MyType as subComp1 
     primitive {
       source myImplementation.c;
       attribute int attr1 = a;
     }
   ...
 }</programlisting>
    </example>
    
    <warning>
      <para>Anonymous definitions must be used sparingly since it may lead to 
        ADL files that are difficult to read. Obviously, the definition of complex
        architectures is in a monolithic ADL file should be avoided for 
        convenience and reusability reasons.</para>
    </warning>
  </section>
  
<!--#########################################################################-->
<!-- Annotation                                                              -->
<!--#########################################################################-->
  
  <section id="adl-annot">
    <title>ADL Annotations</title>

    <para>The ADL language supports <emphasis>annotations</emphasis> as a generic way
      to attach additional information on various elements of the language. The annotation system
      is directly inspired by Java and reuses its syntax.</para>
    
    <para>An annotation declaration starts with a <code>"@"</code> symbol followed by the fully-qualified-name
      of the annotation. An annotation can have fields that are initialized 
      in between parenthesis as a comma separated list of 
      <code><replaceable>name</replaceable>=<replaceable>value</replaceable></code> pairs.
      A field value can be a literal constant (integer, boolean or string), another annotation,
      or an array of values.</para>
    
    <para>If the annotation have a single field called <varname>value</varname>, 
      then the value of this field can be directly put between parenthesis without
      specifying its name.</para>
    
    <example>
      <title>Annotation</title>
      
      <programlisting linenumbering="numbered" language="adl"> @CFlags("-O3")
 composite foo.bar.APrimitive 
     extends foo.bar.AnotherPrimitive { 
   
   @MyAnnotation(f1="toto", f2={12, 13, 56})
   provides Itf1 as itf1;
   
   @Override
   attribute attr1 = 2; 
   
 }</programlisting>
 
      <para>
        <note>
          <itemizedlist>
            <listitem>
              <para>At line 1, the <classname>CFlags</classname> annotation 
                is attached to the definition. This annotation has one field that
                is assigned to <code>"-O3"</code>. This annotation is a predefined
                ADL annotation; see <xref linkend="adl-annot-cflags"/> for more details.</para>
            </listitem>
            <listitem>
              <para>At line 5, the <classname>MyAnnotation</classname> annotation
              is attached to the specification of the <varname>itf1</varname> interface.
              This annotation has two fields <varname>f1</varname> and <varname>f2</varname>.
              The first field takes as value, the <code>"toto"</code> string; while the second
              one takes as value, an array of three integers. </para>
            </listitem>
            <listitem>
              <para>At line 8, the <classname>Override</classname> annotation
              is attached to the specification of the <varname>attr1</varname> attribute.
              This annotation has no fields. This annotation is a predefined
              ADL annotation; see <xref linkend="adl-annot-override"/> for more details.</para>
            </listitem>
          </itemizedlist>
        </note>
      </para>
    </example>
    
    <section id="adl-annot-predef">
      <title>Predefined ADL Annotations</title>

      <para>The &productName; toolchain supports a set of predefined annotations that are listed
        in this section</para>
        
      <para>In the following descriptions, the <emphasis>Annotation fields</emphasis> paragraph 
        specifies the fields of the annotation and the <emphasis>Annotation targets</emphasis> paragraph
        specifies on which kind of element the annotation can be attached. </para>

      <section id="adl-annot-override">
        <title><classname>@Override</classname></title>
        
        <formalpara>
          <title>Annotation fields</title>
          <para>No fields</para>
        </formalpara>
        
        <formalpara>
          <title>Annotation targets</title>
          <para>
            <simplelist type="inline">
              <member>Attribute</member>
              <member>Data</member>
              <member>Sub-component</member>
              <member>Binding</member>
            </simplelist>
          </para>
        </formalpara>
        
        <para>The <classname>Override</classname> annotation specifies that the 
          element which it is attached to is supposed to override an inherited element.
          If it is not the case, an error is reported by the &productName; toolchain.</para>

        <para>Note that, this annotation is not required for an element to actually override 
          an inherited element, it is only for verification purpose. In other words,
          there is no problem if a given element overrides an inherited
          element without declaring any <classname>Override</classname> annotation. Indeed, this annotation 
          allows to be more resilient to the modifications of extended 
          definitions. For instance let suppose that we have a definition <replaceable>A</replaceable> that extends a 
          definition <replaceable>B</replaceable> and overrides the specification
          of a sub-component <varname>subComp1</varname> without adding the <code>@Override</code>
          annotation. Say the definition 
          <replaceable>B</replaceable> is updated and the name of the sub-component
          <varname>subComp1</varname> is changed to <varname>subComp2</varname>. 
          Then if the definition <replaceable>A</replaceable> is not updated accordingly, 
          it will have two separate sub-components, namely <varname>subComp1</varname> and 
          <varname>subComp2</varname>. On the other hand, if the  <classname>Override</classname> 
          annotation is declared for <varname>subComp1</varname> in the <replaceable>A</replaceable> definition,
          then a compilation error will occur to prevent the programmer.</para>
      </section>
      
      <section id="adl-annot-singleton">
        <title><classname>@Singleton</classname></title>
        
        <formalpara>
          <title>Annotation fields</title>
          <para>No fields</para>
        </formalpara>
        
        <formalpara>
          <title>Annotation targets</title>
          <para>
            <simplelist type="inline">
              <member>Definition</member>
            </simplelist>
          </para>
        </formalpara>
        
         <para>The <classname>Singleton</classname> annotation specifies that the 
           definition can be instantiated only a single time in a given application.
           An error is reported by the &productName; toolchain if a definition 
           with this annotation is instantiated more that once in an application.</para>
          
         <note><para>Composite definition that contains at least on singleton 
           sub-component are implicitly declared singleton. It is recommanded to 
           add explicitly the <classname>Singleton</classname> annotation on such
           composite definition.</para></note>
           
         <note><para>Instantiating a generic definition by passing a singleton 
           definition as value result in a singleton definition.</para></note>
      </section>
      
      <section id="adl-annot-cflags">
        <title><classname>@CFlags</classname></title>
        
        <formalpara>
          <title>Annotation fields</title>
          <para>One field called <varname>value</varname> of type <varname>string</varname></para>
        </formalpara>
        
        <formalpara>
          <title>Annotation targets</title>
          <para>
            <simplelist type="inline">
              <member>Definition</member>
              <member>Source</member>
            </simplelist>
          </para>
        </formalpara>
        
        <para>The <classname>CFlags</classname> annotation allows to specify 
          compilation flags that must be used for the compilation of the source-files 
          of a component definition.</para>
        
        <para>This annotation can be attached to the definition, so that given flags 
          are used for the compilation of the set of source-files of the definition. 
          It can also be attached to an individual source specification to
          specify the compilation flags to be used only for a specific source file.</para>
      </section>
      
      <section id="adl-annot-ldflags">
        <title><classname>@LDFlags</classname></title>
        
        <formalpara>
          <title>Annotation fields</title>
          <para>One field called <varname>value</varname> of type <varname>string</varname></para>
        </formalpara>
        
        <formalpara>
          <title>Annotation targets</title>
          <para>
            <simplelist type="inline">
              <member>Definition</member>
              <member>Source</member>
            </simplelist>
          </para>
        </formalpara>
        
        <para>The <classname>LDFlags</classname> annotation allows to specify 
          flags that must be used at the link phase of applications that
          contains at least one instance of this definition.</para>
        
        <para>This annotation can be attached to the definition or to an individual 
          source specification. In practice, this make no difference since the 
          flags are used for the link of the whole application. Nevertheless, 
          if a flag can be attached to a given source specification to indicate
          that this is this particular source file that requires this flag.</para>
        
        <para>Specifying LD-Flags in ADL is particularly usefull for primitive components
          that use shared libraries in their code. It ensures that the link
          flag (for instance <code>-lm</code> if the code use the math library)
          is always present for the link of an application that use such primitive component.</para>
      </section>
      
      <section id="adl-annot-useIDL">
        <title><classname>@UseIDL</classname></title>
        
        <formalpara>
          <title>Annotation fields</title>
          <para>One field called <varname>value</varname> of type <varname>string[]</varname></para>
        </formalpara>
        
        <formalpara>
          <title>Annotation targets</title>
          <para>
            <simplelist type="inline">
              <member>Definition</member>
            </simplelist>
          </para>
        </formalpara>
        
        <para>The <classname>UseIDL</classname> annotation allows to specify 
          IDL interfaces that are used internally by the component implementation
          and that are not explicitly declared as a provided or required 
          interface.</para>
        
        <para>This annotation must be attached to a definition (usualy a 
          definition of primitive component).</para>
        
        <para>This is particularly useful if the component implementation 
          cast pointers to interface types that are not directly accessible
          through the IDL of the provided or required interfaces.</para>
      </section>
            
      <section id="adl-annot-wrap">
        <title><classname>@Wrap</classname></title>
        
        <formalpara>
          <title>Annotation fields</title>
          <para>No fields</para>
        </formalpara>
        
        <formalpara>
          <title>Annotation targets</title>
          <para>
            <simplelist type="inline">
              <member>Server interface</member>
            </simplelist>
          </para>
        </formalpara>

        <para>The <classname>Wrap</classname> annotation allows to specify 
          that the implementation of a provided interface will be automatically 
          generated wrapping each corresponding C functions into interface methods. 
          Wrapping a function corresponds in defining a method that makes the call 
          this function. The generated method returns the same type as the C 
          function and generally takes the same parameters. This approach is 
          close to the ld <varname>--wrap</varname> option.</para>
          
        <note><para>Wrapping a varadic function needs complementary information 
        to know the name of the dual function. Actually, as the number of 
        parameters of a variadic function can't be determined apriori, the call 
        to this function can't be done directly but through a function assuring
        the same functionality having a <varname>va_list</varname> and a 
        <varname>format</varname> as parameters. This specification will be done 
        using the <varname>@VarArgsDual</varname> annotation (see 
        <xref linkend="idl-annot-varargsdual"/>) in the corresponding IDL.</para></note>
      </section>
      
    </section>
  </section>
  
  <section id="adl-grammar">
    <title>Complete ADL grammar</title>

    <para>
      The following listing describe the complete grammar of the ADL language
    </para>
    <productionset>
      <title>Top-level grammar</title>

      <production id="adlgrammar-ADLFile">
        <lhs>ADLFile</lhs>
        <rhs>
          ( <nonterminal def="#adlgrammar-Import" /> ) * <nonterminal def="#adlgrammar-Type" /> <sbr />
          | ( <nonterminal def="#adlgrammar-Import" /> ) * <nonterminal def="#adlgrammar-Primitive" /> <sbr />
          | ( <nonterminal def="#adlgrammar-Import" /> ) * <nonterminal def="#adlgrammar-Composite" /> <sbr />
        </rhs>
      </production>

      <production id="adlgrammar-Import">
        <lhs>Import</lhs>
        <rhs>
          <nonterminal def="#adlgrammar-Annotations" /> <sbr />
          'import' &lt;ID&gt; '.' ( &lt;ID&gt; '.' ) * ( '*' | &lt;ID&gt; ) [ ';' ] <sbr />
        </rhs>
      </production>

    </productionset>



    <productionset>
      <title>Type definition grammar</title>

      <production id="adlgrammar-Type">
        <lhs>Type</lhs>
        <rhs>
          <nonterminal def="#adlgrammar-Annotations" /> <sbr />
          'type' <nonterminal def="#adlgrammar-FQN" /> <sbr />
          [ 'extends' <nonterminal def="#adlgrammar-FQN" /> ( ',' <nonterminal def="#adlgrammar-FQN" /> ) * ] <sbr />
          <nonterminal def="#adlgrammar-TypeBody" /> <sbr />
        </rhs>
      </production>

      <production id="adlgrammar-TypeBody">
        <lhs>TypeBody</lhs>
        <rhs>
          '{' <nonterminal def="#adlgrammar-TypeElem" /> * '}' <sbr />
          | <nonterminal def="#adlgrammar-TypeElem" /> <sbr />
        </rhs>
      </production>

      <production id="adlgrammar-TypeElem">
        <lhs>TypeElem</lhs>
        <rhs>
          <nonterminal def="#adlgrammar-ItfDef" /> <sbr />
        </rhs>
      </production>

    </productionset>



    <productionset>
      <title>Primitive definition grammar</title>

      <production id="adlgrammar-Primitive">
        <lhs>Primitive</lhs>
        <rhs>
          <nonterminal def="#adlgrammar-Annotations" /> <sbr />
          [ 'abstract' ] 'primitive' <nonterminal def="#adlgrammar-FQN" /> <sbr />
          [ <nonterminal def="#adlgrammar-ParamDecl" /> ]
          <sbr />
          [ 'extends' <nonterminal def="#adlgrammar-PrimitiveRef" /> ( ',' <nonterminal def="#adlgrammar-PrimitiveRef" /> ) * ] <sbr />
          <nonterminal def="#adlgrammar-PrimitiveBody" /> <sbr />
        </rhs>
      </production>

      <production id="adlgrammar-ParamDecl">
        <lhs>ParamDecl</lhs>
        <rhs>
          '(' &lt;ID&gt; ( ',' &lt;ID&gt;) * ')' <sbr />
        </rhs>
      </production>

      <production id="adlgrammar-PrimitiveRef">
        <lhs>PrimitiveRef</lhs>
        <rhs>
          <nonterminal def="#adlgrammar-FQN" /> [ '(' [ <nonterminal def="#adlgrammar-ArgList" /> ] ')' ] <sbr />
        </rhs>
      </production>

      <production id="adlgrammar-ArgList">
        <lhs>ArgList</lhs>
        <rhs>
          <nonterminal def="#adlgrammar-ArgValue" /> ( ',' <nonterminal def="#adlgrammar-ArgValue" /> ) * <sbr />
          | <nonterminal def="#adlgrammar-ArgAssign" /> ( ',' <nonterminal def="#adlgrammar-ArgAssign" /> ) * <sbr />
        </rhs>
      </production>

      <production id="adlgrammar-ArgValue">
        <lhs>ArgValue</lhs>
        <rhs>
          <nonterminal def="#adlgrammar-String" />  <sbr />
          | <nonterminal def="#adlgrammar-Integer" /> <sbr />
          | &lt;ID&gt; <sbr />
        </rhs>
      </production>

      <production id="adlgrammar-ArgAssign">
        <lhs>ArgAssign</lhs>
        <rhs>
          &lt;ID&gt; '=' <nonterminal def="#adlgrammar-ArgValue" /> <sbr />
        </rhs>
      </production>

      <production id="adlgrammar-PrimitiveBody">
        <lhs>PrimitiveBody</lhs>
        <rhs>
          '{' <nonterminal def="#adlgrammar-PrimitiveElem" /> * '}' <sbr />
          | <nonterminal def="#adlgrammar-PrimitiveElem" /> <sbr />
        </rhs>
      </production>

      <production id="adlgrammar-PrimitiveElem">
        <lhs>PrimitiveElem</lhs>
        <rhs>
          <nonterminal def="#adlgrammar-ItfDef" /> <sbr />
          | <nonterminal def="#adlgrammar-AttrDef" /> <sbr />
          | <nonterminal def="#adlgrammar-DataDef" /> <sbr />
          | <nonterminal def="#adlgrammar-ImplDef" /> <sbr />
        </rhs>
      </production>
           
    </productionset>



    <productionset>
      <title>Composite definition grammar</title>

    
      <production id="adlgrammar-Composite">
        <lhs>Composite</lhs>
        <rhs>
          <nonterminal def="#adlgrammar-Annotations" /> <sbr />
          'composite' <nonterminal def="#adlgrammar-FQN" /> <sbr />
          [ <nonterminal def="#adlgrammar-TmplVarDecls" /> ] <sbr />
          [ <nonterminal def="#adlgrammar-ParamDecl" /> ] <sbr />
          [ 'extends' <nonterminal def="#adlgrammar-CompositeRef" /> ( ',' <nonterminal def="#adlgrammar-CompositeRef" /> ) * ] <sbr />
          <nonterminal def="#adlgrammar-CompositeBody" /> <sbr />
        </rhs>
      </production>      
      
      <production id="adlgrammar-TmplVarDecls">
        <lhs>TmplVarDecl</lhs>
        <rhs>
          '&lt;' <nonterminal def="#adlgrammar-TmplVarDecl" /> ( ',' <nonterminal def="#adlgrammar-TmplVarDecl" /> ) * '&gt;' <sbr />
        </rhs>
      </production>
      
      <production id="adlgrammar-TmplVarDecl">
        <lhs>TmplVarDecl</lhs>
        <rhs>
          &lt;ID&gt; 'conformsto' <nonterminal def="#adlgrammar-FQN" /> <sbr />
        </rhs>
      </production>
      
      <production id="adlgrammar-CompositeRef">
        <lhs>CompositeRef</lhs>
        <rhs>
          <nonterminal def="#adlgrammar-FQN" /> <sbr />
          [ '&lt;' [ <nonterminal def="#adlgrammar-TmplValueList" /> ] '&gt;' ] <sbr />
          [ '(' [ <nonterminal def="#adlgrammar-ArgList" /> ] ')' ] <sbr />
        </rhs>
      </production>
      
      <production id="adlgrammar-TmplValueList">
        <lhs>TmplValueList</lhs>
        <rhs>
          <nonterminal def="#adlgrammar-TmplValue" /> ( ',' <nonterminal def="#adlgrammar-TmplValue" /> ) * <sbr />
          | <nonterminal def="#adlgrammar-TmplAssign" /> ( ',' <nonterminal def="#adlgrammar-TmplAssign" /> ) * <sbr />
        </rhs>
      </production>

      <production id="adlgrammar-TmplValue">
        <lhs>TmplValue</lhs>
        <rhs>
          <nonterminal def="#adlgrammar-CompositeRef" /> <sbr />
          | '?' <sbr />
        </rhs>
      </production>

      <production id="adlgrammar-TmplAssign">
        <lhs>TmplAssign</lhs>
        <rhs>
          &lt;ID&gt; '=' <nonterminal def="#adlgrammar-TmplValue" /> <sbr />
        </rhs>
      </production>
      
      <production id="adlgrammar-CompositeBody">
        <lhs>CompositeBody</lhs>
        <rhs>
          '{' <nonterminal def="#adlgrammar-CompositeElem" /> * '}' <sbr />
          | <nonterminal def="#adlgrammar-CompositeElem" /> <sbr />
        </rhs>
      </production>

      <production id="adlgrammar-CompositeElem">
        <lhs>CompositeElem</lhs>
        <rhs>
          <nonterminal def="#adlgrammar-ItfDef" /> <sbr />
          | <nonterminal def="#adlgrammar-BindingDef" /> <sbr />
          | <nonterminal def="#adlgrammar-CompDef" /> <sbr />
        </rhs>
      </production>
      
    </productionset>



    <productionset>
      <title>Interface grammar</title>

      <production id="adlgrammar-ItfDef">
        <lhs>ItfDef</lhs>
        <rhs>
          <nonterminal def="#adlgrammar-Annotations" /> <sbr />
          ( 'provides' | 'requires' ) [ 'optional' ] <nonterminal def="#adlgrammar-FQN" /> <sbr/>
          'as' &lt;ID&gt; [ '[' [ &lt;INTEGER_LITERAL&gt; ] ']' ] [ ';' ] <sbr />
        </rhs>
      </production>

    </productionset>

    <productionset>
      <title>Attribute grammar</title>

      <production id="adlgrammar-AttrDef">
        <lhs>AttrDef</lhs>
        <rhs>
          <nonterminal def="#adlgrammar-Annotations" /> <sbr />
          'attribute' <nonterminal def="#adlgrammar-AttrType" /> <sbr/>
          &lt;ID&gt; [ '='  <nonterminal def="#adlgrammar-AttrValue" /> ] [ ';' ] <sbr />
        </rhs>
      </production>

      <production id="adlgrammar-AttrType">
        <lhs>AttrType</lhs>
        <rhs>
          'int' | 'string' <sbr />
        </rhs>
      </production>

      <production id="adlgrammar-AttrValue">
        <lhs>AttrValue</lhs>
        <rhs>
          <nonterminal def="#adlgrammar-String" />  <sbr />
          | <nonterminal def="#adlgrammar-Integer" />  <sbr />
          |  &lt;ID&gt; <sbr />
        </rhs>
      </production>

    </productionset>

    <productionset>
      <title>Implementation grammar</title>

      <production id="adlgrammar-DataDef">
        <lhs>DataDef</lhs>
        <rhs>
          <nonterminal def="#adlgrammar-Annotations" /> <sbr />
          'data' (<nonterminal def="#adlgrammar-Path" /> | &lt;INLINE_CODE&gt;) [ ';' ] <sbr/>
        </rhs>
      </production>

      <production id="adlgrammar-ImplDef">
        <lhs>ImplDef</lhs>
        <rhs>
          <nonterminal def="#adlgrammar-Annotations" /> <sbr />
          'source' (<nonterminal def="#adlgrammar-Path" /> | &lt;INLINE_CODE&gt;) [ ';' ] <sbr />
        </rhs>
      </production>
      
    </productionset>

    <productionset>
      <title>Binding grammar</title>

      <production id="adlgrammar-BindingDef">
        <lhs>BindingDef</lhs>
        <rhs>
          <nonterminal def="#adlgrammar-Annotations" /> <sbr />
          'binds' <nonterminal def="#adlgrammar-BindingEnd"/> <sbr />
          'to' <nonterminal def="#adlgrammar-BindingEnd"/> [ ';' ] <sbr />
        </rhs>
      </production>
      
      <production id="adlgrammar-BindingEnd">
        <lhs>BindingEnd</lhs>
        <rhs>
          ( &lt;ID&gt; | 'this' ) '.' &lt;ID&gt; [ '[' &lt;INTEGER_LITERAL&gt; ']' ] <sbr />
        </rhs>
      </production>
      
    </productionset>


    <productionset>
      <title>Sub-component grammar</title>

      <production id="adlgrammar-CompDef">
        <lhs>CompDef</lhs>
        <rhs>
          <nonterminal def="#adlgrammar-Annotations" /> <sbr />
          'contains' [ <nonterminal def="#adlgrammar-CompositeRef" /> ] <sbr />
           'as'  &lt;ID&gt;<sbr />
          [ <nonterminal def="#adlgrammar-AnonymousC" /> |  <nonterminal def="#adlgrammar-AnonymousP" />]
           <sbr />
        </rhs>
      </production>
      
      <production id="adlgrammar-AnonymousC">
        <lhs>AnonymousC</lhs>
        <rhs>
          <nonterminal def="#adlgrammar-Annotations" /> <sbr />
          '{' <nonterminal def="#adlgrammar-CompositeElem" /> * '}'
          <sbr />
        </rhs>
      </production>

      <production id="adlgrammar-AnonymousP">
        <lhs>AnonymousP</lhs>
        <rhs>
          <nonterminal def="#adlgrammar-Annotations" /> <sbr />
          '{' <nonterminal def="#adlgrammar-PrimitiveElem" /> * '}'
          <sbr />
        </rhs>
      </production>

    </productionset>
 
    <productionset>
      <title>Annotation grammar</title>

      <production id="adlgrammar-Annotations">
        <lhs>Annotations</lhs>
        <rhs>
          <nonterminal def="#adlgrammar-Annotation" /> * <sbr />
        </rhs>
      </production>

      <production id="adlgrammar-Annotation">
        <lhs>Annotation</lhs>
        <rhs>
          '@' <nonterminal def="#adlgrammar-FQN" /> <sbr/>
          [ <nonterminal def="#adlgrammar-AnnoParams" /> ] <sbr />
        </rhs>
      </production>

      <production id="adlgrammar-AnnoParams">
        <lhs>AnnoParams</lhs>
        <rhs>
          '(' [ <nonterminal def="#adlgrammar-AnnoVPairs" /> <sbr/>
           | <nonterminal def="#adlgrammar-AnnoValue" /> ] ')' 
          <sbr />
        </rhs>
      </production>
      
      <production id="adlgrammar-AnnoVPairs">
        <lhs>AnnoVPairs</lhs>
        <rhs>
          <nonterminal def="#adlgrammar-AnnoVPair" /> ( ',' <nonterminal def="#adlgrammar-AnnoVPair" /> ) *
          <sbr />
        </rhs>
      </production>

      <production id="adlgrammar-AnnoVPair">
        <lhs>AnnoVPair</lhs>
        <rhs>
          &lt;ID&gt; '=' <nonterminal def="#adlgrammar-AnnoValue" /> <sbr />
        </rhs>
      </production>

      <production id="adlgrammar-AnnoValue">
        <lhs>AnnoValue</lhs>
        <rhs>
          <nonterminal def="#adlgrammar-String" /> <sbr/>
          | <nonterminal def="#adlgrammar-Integer" /> <sbr/> 
          | <nonterminal def="#adlgrammar-Boolean" /> <sbr/> 
          | <nonterminal def="#adlgrammar-Annotation" /> <sbr/> 
          | <nonterminal def="#adlgrammar-AnnoArrayV" /> <sbr/> 
          <sbr />
        </rhs>
      </production>

      <production id="adlgrammar-AnnoArrayV">
        <lhs>AnnoArrayV</lhs>
        <rhs>
          '{' [ <nonterminal def="#adlgrammar-AnnoValue" /> ( ',' <nonterminal def="#adlgrammar-AnnoValue" /> ) * ] '}'
          <sbr />
        </rhs>
      </production>

    </productionset>
 
    <productionset>
      <title>Other grammar</title>


      <production id="adlgrammar-FQN">
        <lhs>FQN</lhs>
        <rhs>
          &lt;ID&gt; ( '.' &lt;ID&gt; ) * <sbr />
          </rhs>
      </production>

      <production id="adlgrammar-Path">
        <lhs>Path</lhs>
        <rhs>
          [ '.' '/' ] ( '..' '/' ) * <sbr />
          &lt;ID&gt; ( '/' &lt;ID&gt; ) * '.' &lt;ID&gt; <sbr />
          </rhs>
      </production>

      <production id="adlgrammar-String">
        <lhs>String</lhs>
        <rhs>
          &lt;STRING_LITERAL&gt; <sbr />
        </rhs>
      </production>

      <production id="adlgrammar-Integer">
        <lhs>Integer</lhs>
        <rhs>
          [ '+' | '-' ] &lt;INTEGER_LITERAL&gt; <sbr />
        </rhs>
      </production>

      <production id="adlgrammar-Boolean">
        <lhs>Boolean</lhs>
        <rhs>
          'true' | 'false' <sbr />
        </rhs>
      </production>

    </productionset>
    
  </section>
</section>
